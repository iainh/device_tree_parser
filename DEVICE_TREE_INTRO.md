# Introduction to Device Trees

This document provides an accessible introduction to Device Trees for developers new to embedded systems or hardware description languages.

## What Are Device Trees?

**Device Trees** are a standardized way to describe computer hardware in a format that software can understand. Think of them as a "blueprint" or "map" that tells the operating system what hardware components are present and how they're connected.

### The Problem Device Trees Solve

In traditional PC systems, hardware can be **automatically discovered**:
- PCI devices announce themselves
- USB devices identify when plugged in  
- ACPI tables describe system resources

But in **embedded systems**:
- Hardware is often **fixed** and **custom**
- No automatic discovery mechanisms
- Direct memory-mapped access to devices
- Custom interrupt routing and addressing

Device Trees bridge this gap by providing a **hardware description** that software can read.

## Real-World Example

Consider a simple embedded board with:
- ARM processor
- 2 UART serial ports  
- SPI flash memory
- GPIO pins
- Timer

Without a device tree, the operating system has no way to know:
- Where these devices are located in memory
- Which interrupts they use
- How they're connected
- What drivers to load

With a device tree, this information is explicitly described.

## Device Tree Formats

### 1. Device Tree Source (DTS) - Human Readable

```dts
/ {
    model = "Example Board";
    compatible = "example,board-v1";
    
    cpus {
        cpu@0 {
            device_type = "cpu";
            compatible = "arm,cortex-a53";
            reg = <0>;
        };
    };
    
    uart0: uart@1000 {
        compatible = "ns16550a";
        reg = <0x1000 0x100>;
        interrupts = <10>;
        status = "okay";
    };
    
    memory@80000000 {
        device_type = "memory";
        reg = <0x80000000 0x10000000>; // 256MB at 0x80000000
    };
};
```

### 2. Device Tree Blob (DTB) - Binary Compiled

The **DTB** is the compiled binary version that bootloaders and kernels actually use:
- Compact and efficient to parse
- Contains the same information as DTS
- Generated by the Device Tree Compiler (dtc)

**This library parses DTB files.**

## Key Concepts

### Nodes
**Nodes** represent hardware components or logical groupings:

```
/              <- Root node (the system)
├── cpus/      <- CPU information  
├── memory@... <- System memory
├── uart@1000  <- Serial port at address 0x1000
└── spi@2000   <- SPI controller at address 0x2000
```

### Properties
**Properties** are key-value pairs describing node characteristics:

| Property | Type | Purpose | Example |
|----------|------|---------|---------|
| `compatible` | string | Device identification | `"ns16550a"` |
| `reg` | array | Address/size pairs | `<0x1000 0x100>` |
| `interrupts` | array | Interrupt numbers | `<10>` |
| `status` | string | Enable/disable | `"okay"` or `"disabled"` |

### Addressing
Device trees use a **hierarchical addressing** system:

```dts
soc {
    #address-cells = <1>;  // Addresses are 1 cell (32-bit)
    #size-cells = <1>;     // Sizes are 1 cell (32-bit)
    
    uart@1000 {
        reg = <0x1000 0x100>;  // Address 0x1000, size 0x100 bytes
    };
};
```

## Common Device Tree Patterns

### 1. Device Identification
```dts
uart@1000 {
    compatible = "vendor,specific-uart", "ns16550a", "ns16550";
    // Matches most specific first, falls back to generic
};
```

### 2. Resource Description  
```dts
ethernet@5000 {
    reg = <0x5000 0x1000>;        // Memory-mapped registers
    interrupts = <25>;            // Interrupt line
    dma-channels = <2>;           // DMA channel count
    clock-frequency = <125000000>; // 125MHz clock
};
```

### 3. Inter-device Relationships
```dts
i2c@3000 {
    temperature-sensor@48 {
        compatible = "ti,tmp102";
        reg = <0x48>;  // I2C address
    };
};
```

## How Bootloaders and Kernels Use Device Trees

### Boot Process
1. **Bootloader** (U-Boot, etc.) loads DTB into memory
2. **Kernel** receives DTB location from bootloader  
3. **Kernel** parses DTB to discover hardware
4. **Device drivers** use DTB info to configure hardware

### Driver Matching
```c
// Linux kernel driver
static const struct of_device_id uart_ids[] = {
    { .compatible = "ns16550a" },
    { .compatible = "ns16550" },
    { /* sentinel */ }
};

// Kernel automatically matches DTB compatible strings to drivers
```

## Why Use This Library?

This `device_tree_parser` library lets you:

### 1. **Parse DTB Files**
```rust
use device_tree_parser::DeviceTreeParser;

let dtb_data = std::fs::read("system.dtb")?;
let parser = DeviceTreeParser::new(&dtb_data);
let tree = parser.parse_tree()?;
```

### 2. **Extract Hardware Information**
```rust
// Find all UART devices
let uarts = tree.find_compatible_nodes("ns16550a");
for uart in uarts {
    if let Some(reg) = uart.prop_u32_array("reg") {
        println!("UART at address: 0x{:x}", reg[0]);
    }
}
```

### 3. **Build Tools and Utilities**
- Hardware discovery tools
- System configuration generators  
- Bootloader utilities
- Development and debugging tools

## Use Cases

### Embedded Development
- **Board bring-up**: Verify hardware descriptions
- **Driver development**: Extract device configuration
- **System integration**: Understand hardware layout

### Tools and Utilities  
- **Device tree analyzers**: Parse and validate DTB files
- **Hardware documentation**: Generate system maps
- **Configuration tools**: Convert between formats

### Education and Research
- **Learn embedded systems**: Understand hardware-software interface  
- **Reverse engineering**: Analyze system configurations
- **Academic projects**: Study device tree structures

## Getting Started

### 1. Obtain a DTB File
```bash
# From running system (Linux)
cp /sys/firmware/devicetree/base /tmp/system.dtb

# From compiled DTS
dtc -I dts -O dtb system.dts -o system.dtb

# From QEMU
qemu-system-arm -machine virt -dumpdtb virt.dtb
```

### 2. Parse with Our Library
```rust
use device_tree_parser::DeviceTreeParser;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let dtb_data = std::fs::read("system.dtb")?;
    let parser = DeviceTreeParser::new(&dtb_data);
    
    // Parse and explore
    let tree = parser.parse_tree()?;
    println!("System model: {:?}", tree.prop_string("model"));
    
    // Find devices
    let uart_addrs = parser.uart_addresses()?;
    println!("UART addresses: {:?}", uart_addrs);
    
    Ok(())
}
```

## Next Steps

1. **Read the specification**: [DEVICE_TREE_SPECIFICATION.md](DEVICE_TREE_SPECIFICATION.md)
2. **Try the examples**: Run `cargo run --example parse_dtb`
3. **Explore the API**: Check the [API documentation](https://docs.rs/device_tree_parser)
4. **Join the community**: Contribute to embedded Rust ecosystem

Device Trees are fundamental to embedded systems development. Understanding them opens doors to working with a vast ecosystem of embedded hardware and software.